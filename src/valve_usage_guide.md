# Інструкція по використанню пневматичних клапанів

## Основні функції клапанів

### 1. Базові функції
```cpp
valve1.on();    // Увімкнути клапан
valve1.off();   // Вимкнути клапан
valve1.toggle(); // Перемкнути стан
valve1.isOn();  // Перевірити чи увімкнений
```

### 2. Таймерні функції
```cpp
valve1.onFor(1000);  // Увімкнути на 1 секунду, потім автоматично вимкнути
valve1.offFor(1000); // Вимкнути на 1 секунду, потім автоматично увімкнути
```

## ⚠️ ВАЖЛИВО! Обов'язкове оновлення

**КРИТИЧНО**: Функції `onFor()` та `offFor()` працюють тільки якщо викликати `update()` для кожного клапана в `loop()`:

```cpp
void loop() {
    // ОБОВ'ЯЗКОВО викликати update() для всіх клапанів!
    valve1.update();
    valve2.update();
    valve3.update();
    // ... всі інші клапани
    
    // Ваш код...
}
```

## Приклади використання

### Приклад 1: Простий таймер
```cpp
void commandSpiceOut() {
    Serial.println("Activating spice valve for 2 seconds...");
    valve1.onFor(2000); // Увімкнути на 2 секунди
    // Клапан автоматично вимкнеться через 2 секунди
}
```

### Приклад 2: Затримка перед увімкненням
```cpp
void commandPaintValveOpen() {
    Serial.println("Waiting 1 second, then opening valve...");
    valve2.offFor(1000); // Вимкнути на 1 секунду, потім увімкнути
    // Клапан буде вимкнений 1 секунду, потім автоматично увімкнеться
}
```

### Приклад 3: Послідовність операцій
```cpp
void commandComplexOperation() {
    // Крок 1: Увімкнути клапан 1 на 1 секунду
    valve1.onFor(1000);
    
    // Крок 2: Затримка 500мс
    delay(500);
    
    // Крок 3: Увімкнути клапан 2 на 2 секунди
    valve2.onFor(2000);
    
    // Крок 4: Вимкнути клапан 3 на 1 секунду, потім увімкнути
    valve3.offFor(1000);
}
```

## Типові помилки

### ❌ НЕПРАВИЛЬНО:
```cpp
void loop() {
    valve1.onFor(1000); // Викликається кожен раз в loop()
    // Клапан буде постійно перезапускатися!
}
```

### ✅ ПРАВИЛЬНО:
```cpp
void loop() {
    valve1.update(); // Оновлення таймера
    
    // Викликати onFor тільки коли потрібно
    if (needToActivateValve) {
        valve1.onFor(1000);
        needToActivateValve = false;
    }
}
```

### ❌ НЕПРАВИЛЬНО:
```cpp
void loop() {
    // Забули викликати update()
    // Таймери не працюватимуть!
}
```

### ✅ ПРАВИЛЬНО:
```cpp
void loop() {
    // ОБОВ'ЯЗКОВО для всіх клапанів
    valve1.update();
    valve2.update();
    valve3.update();
    // ... всі інші
}
```

## Діагностика проблем

### Клапан не вимикається після onFor():
1. Перевірте чи викликається `valve1.update()` в `loop()`
2. Перевірте чи не викликається `onFor()` повторно в `loop()`
3. Перевірте підключення піна

### Клапан не увімкнеться після offFor():
1. Перевірте чи викликається `valve1.update()` в `loop()`
2. Перевірте чи не викликається `offFor()` повторно в `loop()`
3. Перевірте підключення піна

### Клапан працює нестабільно:
1. Перевірте живлення
2. Перевірте чи немає конфліктів з іншими функціями
3. Додайте `delay(10)` в `loop()` для стабільності

## Тестування клапанів

Додайте цей код для тестування:

```cpp
void testValves() {
    static unsigned long lastTest = 0;
    static uint8_t testStep = 0;
    
    if (millis() - lastTest > 2000) { // Кожні 2 секунди
        lastTest = millis();
        
        switch (testStep) {
            case 0:
                Serial.println("Testing valve1.onFor(1000)");
                valve1.onFor(1000);
                break;
            case 1:
                Serial.println("Testing valve2.offFor(1000)");
                valve2.offFor(1000);
                break;
            case 2:
                Serial.println("Testing valve3.on()");
                valve3.on();
                break;
            case 3:
                Serial.println("Testing valve3.off()");
                valve3.off();
                break;
        }
        
        testStep = (testStep + 1) % 4;
    }
}
```

## Примітки

- Функції `onFor()` та `offFor()` використовують `millis()` для таймерів
- Не використовуйте `delay()` в `loop()` якщо можливо
- Завжди викликайте `update()` для всіх клапанів в `loop()`
- Один клапан може мати тільки один активний таймер одночасно 